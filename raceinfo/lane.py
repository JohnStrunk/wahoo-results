# Wahoo! Results - https://github.com/JohnStrunk/wahoo-results
# Copyright (C) 2025 - John D. Strunk
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# pyright: strict
"""The data describing a lane."""

import copy
from dataclasses import dataclass

from .time import Time


@dataclass(kw_only=True)
class Lane:
    """
    The per-lane information for a heat.

    All fields are optional. If a field is not present, it is assumed to not be
    supported by the timing system that generated this lane data. For example,
    an empty ("") `team` name indicates that the system supports team names, but
    the it was not provided for this lane. This is different than a `None`
    value, which indicates that the system does not support team names at all.
    The same logic applies to `backups` and `splits`. An empty `list` is
    different than `None`.

    :param name: The name of the swimmer
    :param team: The name of the swimmer's team
    :param seed_time: The swimmer's seed time
    :param age: The swimmer's age
    :param primary: The primary (pad) time for this lane
    :param backups: The backup times for this lane
    :param splits: The split times for this lane
    :param is_dq: True if the swimmer was disqualified
    :param is_empty: True if the lane is marked empty
    :raises: ValueError if any of the parameters are invalid
    """

    # Swimmer information
    name: str | None = None
    """The name of the swimmer"""
    team: str | None = None
    """The name of the swimmer's team"""
    seed_time: Time | None = None
    """The swimmer's seed time"""
    age: int | None = None
    """The swimmer's age"""

    # Race data
    primary: Time | None = None
    """The primary (pad) time"""
    backups: list[list[Time]] | None = None
    """
    The list of secondary/tertiary/etc times

    backups[0] is the highest priority set of backup times (i.e., the
    secondary), and each successive index is a lower priority set of backup
    times (i.e., tertiary, quaternary, etc.).
    """
    splits: list[Time] | None = None
    """The list of intermediate, cumulative split times"""
    final_time: Time | None = None
    """
    The resolved final time for this lane, if available

    This value is not set by the timing system, but is generated by a resolver
    that integrates the primary, backup, and potentially split times.
    """

    # Flags
    is_dq: bool | None = None
    """True if the swimmer was disqualified"""
    is_empty: bool | None = None
    """True if the lane is marked empty"""

    def __post_init__(self):
        """Validate the lane data."""
        if self.age is not None and self.age < 0:
            raise ValueError("Age must be non-negative")
        if self.seed_time is not None and self.seed_time < 0:
            raise ValueError("Seed time must be non-negative")
        if self.primary is not None and self.primary < 0:
            raise ValueError("Primary time must be non-negative")
        if self.final_time is not None and self.final_time < 0:
            raise ValueError("Final time must be non-negative")
        for backup_set in self.backups or []:
            for backup in backup_set:
                if backup < 0:
                    raise ValueError("Backup times must be non-negative")
        for split in self.splits or []:
            if split < 0:
                raise ValueError("Splits must be non-negative")

    def merge(
        self,
        info_from: "Lane | None" = None,
        results_from: "Lane | None" = None,
    ) -> None:
        """
        Merge another Lane object into this one.

        Merging "info" will overwrite:
        - name, team, seed_time, age

        Merging "results" will overwrite:
        - primary, backups, splits, is_dq, is_empty

        :param info_from: Merge the heat information into this one
        :param results_from: Merge the race data into this one
        """
        if info_from is not None:
            self.name = info_from.name
            self.team = info_from.team
            self.seed_time = info_from.seed_time
            self.age = info_from.age

        if results_from is not None:
            self.primary = results_from.primary
            self.backups = copy.deepcopy(results_from.backups)
            self.splits = copy.deepcopy(results_from.splits)
            self.final_time = results_from.final_time
            self.is_dq = results_from.is_dq
            self.is_empty = results_from.is_empty

    def is_similar_to(self, other: "Lane") -> bool:  # noqa: PLR0911
        """
        Check if this lane is similar to another lane.

        Similarity is defined as having the same values for all fields where a
        field is not None. If a field is None, it is ignored in the comparison.

        Note: This method is mainly intended for testing purposes.

        :param other: The other lane to compare to
        :returns: True if the lanes are similar, False otherwise
        """
        # Compare the simple fields
        for field in [
            "name",
            "team",
            "seed_time",
            "age",
            "primary",
            "final_time",
            "is_dq",
            "is_empty",
        ]:
            if (
                getattr(self, field) is not None
                and getattr(other, field) is not None
                and getattr(other, field) != getattr(self, field)
            ):
                return False
        # Compare the splits
        if self.splits is not None and other.splits is not None:
            if len(self.splits) != len(other.splits):
                return False
            for split1, split2 in zip(self.splits, other.splits):
                if split1 != split2:
                    return False
        # Compare the backups
        if self.backups is not None and other.backups is not None:
            if len(self.backups) != len(other.backups):
                return False
            for backup1, backup2 in zip(self.backups, other.backups):
                if len(backup1) != len(backup2):
                    return False
                for time1, time2 in zip(backup1, backup2):
                    if time1 != time2:
                        return False
        return True
